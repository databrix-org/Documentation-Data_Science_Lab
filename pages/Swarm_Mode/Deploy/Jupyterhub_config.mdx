# Konfiguration Jupyterhub
FÃ¼gen Sie den folgenden Code in die Datei **jupyterhub_config.py** ein.
```js
import subprocess
import json
import sys
import os
from dockerspawner import SwarmSpawner
from dockerspawner import DockerSpawner
from jupyterhub.auth import Authenticator, LocalAuthenticator
from jupyterhub.handlers import BaseHandler
from traitlets import Unicode, List, validate, TraitError
from tornado import web

class ShibbolethLoginHandler(BaseHandler):

    def _write_user_name_in_json(self,username_dict,username,memberstaff):
        idname = ''
        if memberstaff != 'staff;member':
            for k,v in username_dict['student'].items():
                if len(v) < 1:
                    username_dict['student'][k] = username
                    idname = k
                    break
        else:
            for k,v in username_dict['dozent'].items():
                if len(v) < 1:
                    username_dict['dozent'][k] = username
                    idname = k
                    break

        with open('/srv/ngshare/user-name.json', 'w') as file:
            json.dump(username_dict, file)

        return idname


    def _get_user_data_from_request(self):
        """Get shibboleth attributes (user data) from request headers."""
        # print('HEADERS:', self.request.headers)
        # NOTE: The Persistent ID is a triple with the format:
        # <name for the source of the identifier>!
        # <name for the intended audience of the identifier >!
        # <opaque identifier for the principal >
        user_data = {}
        with open('/srv/ngshare/user-name.json', 'r') as file:
            username_dict = json.load(file)

        student_name_dict = {v:k for k,v in username_dict['student'].items()}
        dozent_name_dict = {v:k for k,v in username_dict['dozent'].items()}

        value_list = [self.request.headers.get(header, "") for header in self.authenticator.headers]
        self.log.info("User data debug: %s", value_list)


        if value_list[1] != 'staff;member' and value_list[0]:
                if value_list[0] in student_name_dict.keys():
                    user_data['mail'] = value_list[0]
                    user_data['jh_name'] = student_name_dict[value_list[0]]
                else:
                    user_data['jh_name'] = self._write_user_name_in_json(username_dict,value_list[0],value_list[1])
                    user_data['mail'] = value_list[0]

        if value_list[1] == 'staff;member' and value_list[0]:
                if value_list[0] in dozent_name_dict.keys():
                    user_data['mail'] = value_list[0]
                    user_data['jh_name'] = dozent_name_dict[value_list[0]]
                else:
                    user_data['jh_name'] = self._write_user_name_in_json(username_dict,value_list[0],value_list[1])
                    user_data['mail'] = value_list[0]
        if value_list[0] in ['gu@lehre.dhbw-stuttgart.de']:
                user_data['jh_name'] = value_list[0]
        self.log.info("User data debug: %s", user_data)
        return user_data

    async def get(self):
        """Get user data and log user in."""
        self.statsd.incr('login.request')
        user_data = self._get_user_data_from_request()

        header_name = self.authenticator.header_name
        remote_user = self.request.headers.get(header_name, "")
        if user_data.get('jh_name') is not None:
            user = await self.login_user(user_data)
        elif remote_user != "":
            user = self.user_from_username(remote_user)
            self.set_login_cookie(user)
        else:
            raise web.HTTPError(403)

        if user is None:
            raise web.HTTPError(403)
        else:
            self.redirect(self.get_next_url(user))


class ShibbolethLogoutHandler(BaseHandler):
    """Log a user out from JupyterHub by clearing their login cookie
    and then redirect to shibboleth logout url to clear shibboleth cookie."""
    async def get(self):
        user = await self.get_current_user()
        if user:
            self.log.info("User logged out: %s", user.name)
            self.clear_login_cookie()
            self.statsd.incr('logout')
        self.redirect(self.authenticator.shibboleth_logout_url)


class ShibbolethAuthenticator(Authenticator):
    headers = List(
        default_value=['mail','unscoped-affiliation'],
        config=True,
        help="""List of HTTP headers to get user data. First item is used as unique user name."""
    )
    shibboleth_logout_url = Unicode(
        default_value='',
        config=True,
        help="""Url to logout from shibboleth SP.""")

    header_name = Unicode(
        default_value='REMOTE_USER',
        config=True,
        help="""HTTP header to inspect for the authenticated username.""")

    @validate('headers')
    def _valid_headers(self, proposal):
        if not proposal['value']:
            raise TraitError('Headers should contain at least 1 item.')
        return proposal['value']

    async def authenticate(self, handler, data):
        """
        :param handler: the current request handler (ShibbolethLoginHandler)
        :param data: user data from request headers (shibboleth attributes)
        :return: User data dict in a form that login_user method can process it.
        'name' holds the username and 'auth_state' holds all data requested from shibboleth.
        """
        user_data = {
              'name': data['jh_name'],
              'auth_state': data
              }
        return user_data

    def get_handlers(self, app):
        return [
            (r'/login', ShibbolethLoginHandler),
            (r'/logout', ShibbolethLogoutHandler),
        ]

with open('/srv/ngshare/user-name.json', 'r') as file:
    user_dict = json.load(file)

c.JupyterHub.load_groups = {
                "Dozent":{
                    'users':[i for i in user_dict['dozent'].keys()],
                },
            }

c.JupyterHub.load_roles=[
    {
        "name": "user",
        "scopes": [
            "admin-ui",
            "read:users!user",
            ]
    },

    {
        "name": "jupyterhub-idle-culler-role",
        "scopes": [
            "list:users",
            "read:users:activity",
            "read:servers",
            "delete:servers",
            "admin:users", # if using --cull-users
        ],
        # assignment of role's permissions to:
        "services": ["jupyterhub-idle-culler-service"],
    }
]


check = [0 for i in user_dict['student'].values() if len(i) == 0]
dozent_scope = ["self"]
workspaces = []

for i in [1,2,3,4,5,6,7,8,9,10]:

    group_name = 'gruppe' + str(int(i))
    space_name = 'workspace_gruppe' + str(int(i))
    #workspaces.append(group_name)
    student_name = []
    if check[0] == 0:
        student_name = ['student'+ '0'*( 3 - len(str(j+1)) ) + str(j+1) for j in range( (i-1)*3, i*3 )]
        c.JupyterHub.load_groups[group_name] = {'users':[space_name]+ student_name}
    c.JupyterHub.load_roles.append(
        {
        "name": "gruppen-"+str(i)+"-mitglied",
        "scopes": [
            "access:servers!user=" + space_name,
            "servers!user=" + space_name,
            "read:users!user=" + space_name,
            "users:activity!user=" + space_name,
            "list:users!user=" + space_name,
        ],
        "groups": [group_name],
        }
    )

    dozent_scope.append("access:servers!user=" + space_name)
    dozent_scope.append("servers!user=" + space_name)
    dozent_scope.append("read:users!user=" + space_name)
    dozent_scope.append("users:activity!user=" + space_name)
    dozent_scope.append("list:users!user=" + space_name)
    dozent_scope.append("groups!group=" + group_name)


c.JupyterHub.load_roles.append(
    {"name": "dozent-role",
     "scopes": dozent_scope,
     "groups": ["Dozent"],
    }
)

def pre_spawn_hook(spawner):
    username = spawner.user.name  # get the username
    volume_path = os.path.join('/srv/ngshare/jupyterhub-user-volumes', username)

    if not os.path.exists(volume_path):
        os.mkdir(volume_path, 0o755)
        os.chown(volume_path,1000,1000)

    mounts = [
              {'type': 'bind',
               'source': '/opt/mount/jupyterhub-user-volumes/' + username,
               'target': '/home/jovyan/work'},
              {'type' : 'bind',
               'target' : '/tmp/exchange',
               'source' : '/opt/mount/DHBW-Kurs'}]
    spawner.extra_container_spec = {'mounts': mounts}

# attach the hook function to the spawner
c.Spawner.pre_spawn_hook =  pre_spawn_hook
c.Spawner.debug = True
c.DockerSpawner.notebook_dir = '/home/jovyan/work'
c.SwarmSpawner.cmd = ["jupyterhub-singleuser", "--allow-root"]
c.SwarmSpawmer.use_internal_ip = True
c.SwarmSpawner.network_name = os.environ["DOCKER_NETWORK_NAME"]
c.SwarmSpawner.extra_host_config = { 'network_mode': os.environ["DOCKER_NETWORK_NAME"] }
c.SwarmSpawner.start_timeout = 500
c.Spawner.http_timeout = 60
c.SwarmSpawner.remove = False
c.Spawner.extra_placement_spec = { "constraints": ["node.role == worker"] }
c.ConfigurableHTTPProxy.debug = True

def image_for_user(user):
    "Given a user, return the right image"""
    groups = [group.name for group in user.groups]
    if 'Dozent' in groups:
        return "guyq1997/jupyterlab-dhbw:dozent"
    else:
        return "guyq1997/jupyterlab-dhbw:student"

class MySwarmSpawner(SwarmSpawner):
    def start(self):
        self.image = image_for_user(self.user)
        return super().start()
c.JupyterHub.spawner_class = MySwarmSpawner

c.JupyterHub.default_url = "/jupyterhub/hub/admin"

#c.JupyterHub.base_url = "/jupyterhub"
c.JupyterHub.hub_ip = "0.0.0.0"
#c.JupyterHub.bind_url = 'http://jupyterhub:8000'
#c.JupyterHub.hub_port = 8089  # IP as seen on the docker network. Can also be a hostname.
#c.JupyterHub.port = 8000
c.JupyterHub.bind_url = 'http://0.0.0.0:8000/jupyterhub'

c.JupyterHub.authenticator_class = ShibbolethAuthenticator
c.Authenticator.shibboleth_logout_url = "https://1985609f-7839-4819-8840-2d38548e4ea5.ma.bw-cloud-instance.org/Shibboleth.sso/Logout"c.JupyterHub.admin_access = True
c.Authenticator.admin_users = {'gu@lehre.dhbw-stuttgart.de'}

c.JupyterHub.services = [
    {
        "name": "jupyterhub-idle-culler-service",
        "command": [
            sys.executable,
            "-m", "jupyterhub_idle_culler",
            "--timeout=300",
        ],
         "admin": True,
    }
]

```

## Referecnces

1. [Library fÃ¼r ShibbolethAuthenticator](https://github.com/gesiscss/jhub_shibboleth_auth)
2. [Konfiguration fÃ¼r jupyter-collaboration extension](https://jupyterhub.readthedocs.io/en/stable/tutorial/collaboration-users.html)
3. [Anleitung von Docker Spawner fÃ¼r Jupyterhub](https://jupyterhub-dockerspawner.readthedocs.io/en/latest/spawner-types.html#dockerspawner)
4. [Problembehebung von Persistent Volume mit DockerSpawner](https://discourse.jupyter.org/t/shared-writable-folder-for-each-group/13498/5)
5. [Cut idle Service in Jupyterhub](https://jupyterhub.readthedocs.io/en/stable/rbac/use-cases.html)